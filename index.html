<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Tap Game</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1a202c; /* Dark background */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* Grayish thumb */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* Lighter gray on hover */
        }

        /* Inter font from Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
            color: #e2e8f0; /* Light text color */
            min-height: 100vh; /* Ensure body takes full viewport height */
            width: 100vw; /* Ensure body takes full viewport width */
            margin: 0; /* Remove default margin */
            padding: 0; /* Remove default padding */
            display: flex; /* Ensure flex context for direct children */
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top, not center, to allow scrolling if content overflows */
        }

        /* Custom button styles */
        .btn-primary {
            background: linear-gradient(145deg, #4CAF50, #2E8B57); /* Green gradient */
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.3);
            transition: all 0.3s ease;
        }
        .btn-primary:hover {
            background: linear-gradient(145deg, #2E8B57, #4CAF50);
            box-shadow: 0 6px 20px rgba(0, 255, 0, 0.4);
            transform: translateY(-2px);
        }
        .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 255, 0, 0.2);
        }

        .btn-secondary {
            background: linear-gradient(145deg, #4299E1, #3182CE); /* Blue gradient */
            box-shadow: 0 4px 15px rgba(66, 153, 225, 0.3);
            transition: all 0.3s ease;
        }
        .btn-secondary:hover {
            background: linear-gradient(145deg, #3182CE, #4299E1);
            box-shadow: 0 6px 20px rgba(66, 153, 225, 0.4);
            transform: translateY(-2px);
        }
        .btn-secondary:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(66, 153, 225, 0.2);
        }

        .btn-tertiary {
            background: linear-gradient(145deg, #ECC94B, #D69E2E); /* Yellow/Orange gradient */
            box-shadow: 0 4px 15px rgba(236, 201, 75, 0.3);
            transition: all 0.3s ease;
        }
        .btn-tertiary:hover {
            background: linear-gradient(145deg, #D69E2E, #ECC94B);
            box-shadow: 0 6px 20px rgba(236, 201, 75, 0.4);
            transform: translateY(-2px);
        }
        .btn-tertiary:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(236, 201, 75, 0.2);
        }

        /* Energy bar animation */
        .energy-bar-fill {
            transition: width 0.3s ease-out;
        }

        /* Message box animation */
        .message-box {
            animation: fadeInOut 3s forwards;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(20px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* Tap animation for coins */
        .coin-popup {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            color: #FFD700; /* Gold color */
            pointer-events: none;
            animation: fadeUp 1s forwards;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.7);
        }

        @keyframes fadeUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

        /* Sidebar styles */
        .sidebar {
            position: fixed;
            top: 0;
            left: -250px; /* Hidden by default */
            width: 250px;
            height: 100%;
            background: linear-gradient(180deg, #1a202c, #2d3748); /* Darker background with subtle gradient */
            z-index: 50; /* Above everything else */
            transition: left 0.3s ease-in-out;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
            padding-top: 60px; /* Space for header if any */
        }
        .sidebar.open {
            left: 0; /* Slide in */
        }
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 49; /* Below sidebar, above game content */
            display: none;
        }
        .sidebar-overlay.visible {
            display: block;
        }
        .sidebar-nav-item {
            display: flex;
            align-items: center;
            padding: 1rem 1.5rem;
            color: #a0aec0;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            border-left: 4px solid transparent; /* For active indicator */
        }
        .sidebar-nav-item:hover {
            background-color: #2d3748;
            color: #e2e8f0;
        }
        .sidebar-nav-item.active {
            background-color: #3182ce; /* Blue background for active */
            color: #ffffff; /* White text for active */
            border-left-color: #4299E1; /* Blue border for active */
        }
        .sidebar-nav-item i {
            font-size: 1.25rem;
            margin-right: 1rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col items-center p-4">

    <!-- Sidebar Overlay -->
    <div id="sidebar-overlay" class="sidebar-overlay"></div>

    <!-- Sidebar Menu -->
    <div id="sidebar" class="sidebar flex flex-col">
        <div class="p-4 text-gray-100 text-lg font-bold">Menu</div>
        <button id="sidebar-nav-home-btn" class="sidebar-nav-item active">
            <i class="fas fa-home"></i> Home
        </button>
        <button id="sidebar-nav-upgrades-btn" class="sidebar-nav-item">
            <i class="fas fa-rocket"></i> Upgrades
        </button>
        <button id="sidebar-nav-mines-btn" class="sidebar-nav-item">
            <i class="fas fa-hammer"></i> Mines
        </button>
        <button id="sidebar-nav-referrals-btn" class="sidebar-nav-item">
            <i class="fas fa-users"></i> Referrals
        </button>
        <button id="sidebar-nav-redeem-btn" class="sidebar-nav-item">
            <i class="fas fa-gift"></i> Redeem
        </button>
        <button id="sidebar-nav-membership-btn" class="sidebar-nav-item">
            <i class="fas fa-gem"></i> Membership
        </button>
        <button id="sidebar-nav-dashboard-btn" class="sidebar-nav-item">
            <i class="fas fa-chart-bar"></i> Dashboard
        </button>
        <button id="sidebar-nav-settings-btn" class="sidebar-nav-item">
            <i class="fas fa-cog"></i> Settings
        </button>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-red-900 bg-opacity-95 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-green-500 mx-auto"></div>
            <p class="mt-4 text-lg text-green-400">Loading Game...</p>
        </div>
    </div>

    <!-- Message Box -->
    <div id="message-box" class="fixed top-4 left-1/2 -translate-x-1/2 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden">
        <p id="message-text"></p>
    </div>

    <!-- Telegram-only access message -->
    <div id="telegram-only-message" class="w-full max-w-md bg-gray-800 rounded-xl shadow-2xl p-6 flex flex-col items-center justify-center min-h-[400px] text-center hidden">
        <i class="fab fa-telegram-plane text-6xl text-blue-400 mb-4"></i>
        <h2 class="text-2xl font-bold text-yellow-400 mb-4">Game Access Restricted</h2>
        <p class="text-lg text-gray-300">This game can only be played through our official Telegram bot.</p>
        <p class="text-md text-gray-400 mt-2">Please open it via the bot's menu button.</p>
        </div>

    <!-- Referral/Username Input Section (New, hidden by default) -->
    <div id="new-player-setup-section" class="w-full max-w-md bg-gray-800 rounded-xl shadow-2xl p-6 flex flex-col items-center justify-center min-h-[400px] text-center hidden">
        <h2 class="text-3xl font-bold text-center mb-6 text-yellow-400">Welcome to Crypto Tap!</h2>
        <p class="text-center text-gray-300 mb-4">Let's get you set up.</p>
        <input type="text" id="initial-username-input" placeholder="Choose a Username" class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 mb-4">
        <input type="text" id="initial-referral-code-input" placeholder="Enter referral code (optional)" class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 mb-4">
        <button id="start-new-game-btn" class="btn-primary w-full py-3 px-4 rounded-xl font-bold text-lg">
            Start Game
        </button>
    </div>

    <!-- Main Game Container (All sections are now children of this wrapper) -->
    <div id="game-wrapper" class="w-full max-w-md bg-gray-800 rounded-xl shadow-2xl p-6 relative overflow-hidden" style="min-height: 500px;">
        <!-- Hamburger Menu Icon -->
        <div id="hamburger-menu-btn" class="absolute top-4 left-4 text-2xl text-gray-300 cursor-pointer z-20">
            <i class="fas fa-bars"></i>
        </div>
        <!-- User ID Display (Always visible) -->
        <div class="absolute top-4 right-4 text-xs text-gray-400 z-10">
            User ID: <span id="user-id-display" class="font-mono">Loading...</span>
        </div>

        <!-- Section for Main Game -->
        <div id="game-section" class="w-full flex flex-col items-center hidden">
            <!-- Custom Logo (Bitcoin Icon) -->
            <div id="logo-container" class="mb-4">
                <i class="fab fa-bitcoin text-6xl text-yellow-500"></i>
            </div>

            <!-- Coins Display -->
            <div class="text-center mb-6">
                <h1 class="text-5xl font-extrabold text-yellow-400 flex items-center justify-center">
                    <i class="fas fa-coins mr-3"></i> <span id="coins-display">0</span>
                </h1>
                <p class="text-md text-gray-400 mt-2">Total Coins</p>
            </div>

            <!-- Energy Bar -->
            <div class="w-full bg-gray-700 rounded-full h-4 mb-8 relative">
                <div id="energy-bar-fill" class="bg-gradient-to-r from-green-400 to-blue-500 h-full rounded-full energy-bar-fill" style="width: 100%;"></div>
                <span id="energy-display" class="absolute inset-0 flex items-center justify-center text-xs font-semibold text-white">1000 / 1000</span>
            </div>

            <!-- Tap Button -->
            <div id="tap-area" class="relative w-48 h-48 bg-gradient-to-br from-purple-600 to-indigo-800 rounded-full flex items-center justify-center cursor-pointer shadow-xl transform transition-transform duration-100 active:scale-95 mb-8 overflow-hidden">
                <div class="absolute inset-0 bg-black opacity-20 rounded-full blur-xl"></div>
                <i class="fas fa-hand-pointer text-7xl text-white animate-pulse"></i>
                <span class="absolute text-xl font-bold text-white bottom-4">Tap to Earn!</span>
            </div>

            <button id="daily-reward-btn" class="btn-secondary w-full py-3 px-4 rounded-xl font-bold text-lg flex items-center justify-center mb-6">
                <i class="fas fa-gift mr-2"></i> Daily Reward
            </button>
        </div>


        <!-- Upgrades Section -->
        <div id="upgrades-section" class="w-full flex flex-col items-center hidden">
            <h2 class="text-2xl font-bold text-center mb-4 text-yellow-300">Boost Your Tapping!</h2>

            <!-- Tap Power Upgrade -->
            <div class="flex items-center justify-between bg-gray-800 p-4 rounded-lg mb-3 shadow-md">
                <div>
                    <h3 class="font-semibold text-lg text-green-400"><i class="fas fa-fist-raised mr-2"></i> Tap Power <span id="tap-power-level">(Lv. 0)</span></h3>
                    <p class="text-sm text-gray-300">Increase coins per tap by <span id="tap-power-increase">1</span></p>
                </div>
                <button id="upgrade-tap-power" class="btn-primary py-2 px-4 rounded-lg text-sm font-bold">
                    Buy (<span id="tap-power-cost">100</span> <i class="fas fa-coins"></i>)
                </button>
            </div>

            <!-- Energy Capacity Upgrade -->
            <div class="flex items-center justify-between bg-gray-800 p-4 rounded-lg mb-3 shadow-md">
                <div>
                    <h3 class="font-semibold text-lg text-blue-400"><i class="fas fa-battery-full mr-2"></i> Energy Capacity <span id="energy-capacity-level">(Lv. 0)</span></h3>
                    <p class="text-sm text-gray-300">Increase max energy by <span id="energy-capacity-increase">100</span></p>
                </div>
                <button id="upgrade-energy-capacity" class="btn-primary py-2 px-4 rounded-lg text-sm font-bold">
                    Buy (<span id="energy-capacity-cost">200</span> <i class="fas fa-coins"></i>)
                </button>
            </div>

            <!-- Energy Regeneration Upgrade -->
            <div class="flex items-center justify-between bg-gray-800 p-4 rounded-lg mb-3 shadow-md">
                <div>
                    <h3 class="font-semibold text-lg text-red-400"><i class="fas fa-charging-station mr-2"></i> Energy Regen <span id="energy-regen-level">(Lv. 0)</span></h3>
                    <p class="text-sm text-gray-300">Increase regen rate by <span id="energy-regen-increase">0.1</span>/sec</p>
                </div>
                <button id="upgrade-energy-regen" class="btn-primary py-2 px-4 rounded-lg text-sm font-bold">
                    Buy (<span id="energy-regen-cost">300</span> <i class="fas fa-coins"></i>)
                </button>
            </div>

            <button id="close-upgrades-btn" class="btn-secondary w-full py-3 px-4 rounded-xl font-bold text-lg mt-4">
                <i class="fas fa-arrow-left mr-2"></i> Back
            </button>
        </div>

        <!-- Mining Section -->
        <div id="mining-section" class="w-full flex flex-col items-center hidden">
            <h2 class="text-2xl font-bold text-center mb-4 text-purple-300">Passive Income!</h2>

            <div class="flex justify-between items-center bg-gray-800 p-4 rounded-lg mb-4 shadow-md">
                <div>
                    <h3 class="font-semibold text-lg text-yellow-400"><i class="fas fa-clock mr-2"></i> Hourly Profit: <span id="hourly-profit-display">0</span> <i class="fas fa-coins"></i></h3>
                    <p class="text-sm text-gray-300">Accumulated: <span id="accumulated-profit-display">0</span> <i class="fas fa-coins"></i></p>
                </div>
                <button id="claim-profit-btn" class="btn-primary py-2 px-4 rounded-lg text-sm font-bold">
                    Claim All
                </button>
            </div>

            <div id="cards-list" class="space-y-3">
                </div>

            <button id="close-mining-btn" class="btn-secondary w-full py-3 px-4 rounded-xl font-bold text-lg mt-4">
                <i class="fas fa-arrow-left mr-2"></i> Back
            </button>
        </div>

        <!-- Referrals Section (Moved and Enhanced) -->
        <div id="referrals-section" class="w-full flex flex-col items-center hidden">
            <h2 class="text-2xl font-bold text-center mb-4 text-green-300"><i class="fas fa-users mr-2"></i> Refer & Earn!</h2>

            <div class="bg-gray-800 p-4 rounded-lg mb-4 shadow-md w-full">
                <h3 class="font-semibold text-xl text-green-400 mb-2">Your Referral Link:</h3>
                <p class="text-sm text-gray-300 mb-2">Share this link to invite friends and earn bonuses!</p>
                <div class="flex items-center bg-gray-900 rounded-lg p-3 break-all text-sm font-mono text-blue-300">
                    <span id="referral-link-display" class="flex-grow">Loading referral link...</span>
                    <button id="copy-referral-link-btn" class="ml-2 px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-xs">
                        <i class="fas fa-copy"></i> Copy
                    </button>
                </div>
                <p class="text-sm text-gray-400 mt-2">Referred friends: <span id="referred-count-display">0</span></p>
            </div>

            <button id="close-referrals-btn" class="btn-secondary w-full py-3 px-4 rounded-xl font-bold text-lg mt-4">
                <i class="fas fa-arrow-left mr-2"></i> Back
            </button>
        </div>

        <!-- Redeem Section (New) -->
        <div id="redeem-section" class="w-full flex flex-col items-center hidden">
            <h2 class="text-2xl font-bold text-center mb-4 text-purple-300"><i class="fas fa-trophy mr-2"></i> Redeem Rewards</h2>

            <div class="bg-gray-800 p-4 rounded-lg mb-4 shadow-md w-full">
                <h3 class="font-semibold text-xl text-yellow-400 mb-2">Tasks to Redeem:</h3>
                <ul class="list-disc list-inside text-gray-300 mb-3">
                    <li><span id="redeem-referrals-task">15 Referrals</span></li>
                    <li><span id="redeem-coins-task">240,000,000 Total Coins Earned (XP)</span></li>
                </ul>
                <p class="text-sm text-gray-400 mb-4">Complete both tasks to redeem your reward!</p>
                <button id="redeem-coins-btn" class="btn-primary w-full py-3 px-4 rounded-xl font-bold text-lg opacity-50 cursor-not-allowed" disabled>
                    Redeem Coins (Reward: 10,000,000)
                </button>
                <p id="redeem-status-message" class="text-center text-red-400 text-sm mt-2 hidden">Not all tasks completed yet.</p>
            </div>

            <button id="close-redeem-btn" class="btn-secondary w-full py-3 px-4 rounded-xl font-bold text-lg mt-4">
                <i class="fas fa-arrow-left mr-2"></i> Back
            </button>
        </div>

        <!-- Membership Section (New) -->
        <div id="membership-section" class="w-full flex flex-col items-center hidden">
            <h2 class="text-2xl font-bold text-center mb-4 text-blue-300"><i class="fas fa-gem mr-2"></i> Membership Prices</h2>

            <div class="bg-gray-800 p-4 rounded-lg mb-4 shadow-md w-full text-center">
                <p class="text-lg text-gray-300">Information about membership tiers and prices will go here.</p>
                <p class="text-sm text-gray-400 mt-2">Coming Soon!</p>
            </div>

            <button id="close-membership-btn" class="btn-secondary w-full py-3 px-4 rounded-xl font-bold text-lg mt-4">
                <i class="fas fa-arrow-left mr-2"></i> Back
            </button>
        </div>

        <!-- Dashboard Section (New) -->
        <div id="dashboard-section" class="w-full flex flex-col items-center hidden">
            <h2 class="text-2xl font-bold text-center mb-4 text-yellow-300"><i class="fas fa-chart-bar mr-2"></i> Top 1000 Players</h2>
            <div class="bg-gray-800 p-4 rounded-lg shadow-md w-full max-h-96 overflow-y-auto">
                <table class="w-full text-left table-auto">
                    <thead>
                        <tr class="bg-gray-700">
                            <th class="px-4 py-2 rounded-tl-lg">Rank</th>
                            <th class="px-4 py-2">Username</th>
                            <th class="px-4 py-2 rounded-tr-lg text-right">XP</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboard-list">
                        <tr><td colspan="3" class="text-center py-4 text-gray-400">Loading leaderboard...</td></tr>
                    </tbody>
                </table>
            </div>
            <button id="close-dashboard-btn" class="btn-secondary w-full py-3 px-4 rounded-xl font-bold text-lg mt-4">
                <i class="fas fa-arrow-left mr-2"></i> Back
            </button>
        </div>

        <!-- Settings Section (Updated) -->
        <div id="settings-section" class="w-full flex flex-col items-center hidden">
            <h2 class="text-2xl font-bold text-center mb-4 text-blue-300"><i class="fas fa-cog mr-2"></i> Settings</h2>

            <!-- Username Change Sub-section -->
            <div class="bg-gray-800 p-4 rounded-lg mb-4 shadow-md w-full">
                <h3 class="font-semibold text-xl text-yellow-400 mb-2"><i class="fas fa-user-edit mr-2"></i> Change Username</h3>
                <input type="text" id="username-input" placeholder="New Username" class="w-full p-3 rounded-lg bg-gray-700 border border-gray-600 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 mb-4">
                <button id="save-username-btn" class="btn-primary w-full py-3 px-4 rounded-lg text-sm font-bold">
                    Save Username
                </button>
            </div>

            <!-- Levels Sub-section (Moved from main settings) -->
            <div class="bg-gray-800 p-4 rounded-lg mb-4 shadow-md w-full">
                <h3 class="font-semibold text-xl text-yellow-400 mb-2"><i class="fas fa-star mr-2"></i> Your Level: <span id="player-level-display">1</span></h3>
                <p class="text-sm text-gray-300">XP (Total Coins Earned): <span id="player-xp-display">0</span> / <span id="next-level-xp-display">1000</span></p>
                <div class="w-full bg-gray-700 rounded-full h-2 mt-2">
                    <div id="xp-progress-bar" class="bg-gradient-to-r from-yellow-400 to-orange-500 h-full rounded-full" style="width: 0%;"></div>
                </div>
                <p id="level-reward-info" class="text-sm text-gray-400 mt-2">Next reward: <span id="next-level-reward-display"></span> coins!</p>
            </div>

            <button id="close-settings-btn" class="btn-secondary w-full py-3 px-4 rounded-xl font-bold text-lg mt-4">
                <i class="fas fa-arrow-left mr-2"></i> Back
            </button>
        </div>
    </div>

    <script type="module">
        // Telegram Web Apps SDK
        if (typeof window.Telegram !== 'undefined' && window.Telegram.WebApp) {
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
            console.log("Telegram WebApp is ready!");
        } else {
            console.log("Not running inside Telegram WebApp.");
        }

        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, increment, collection, query, where, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Helper function to show only one section and hide others.
        // Defined at the top level to ensure it's always available.
        window.showSection = function(sectionToShow) { // Made showSection global
            console.log(`Attempting to show section: ${sectionToShow.id}`);
            // Hide all main sections by adding 'hidden' class
            if (gameSection) gameSection.classList.add('hidden');
            if (upgradesSection) upgradesSection.classList.add('hidden');
            if (miningSection) miningSection.classList.add('hidden');
            if (referralsSection) referralsSection.classList.add('hidden');
            if (redeemSection) redeemSection.classList.add('hidden');
            if (membershipSection) membershipSection.classList.add('hidden');
            if (dashboardSection) dashboardSection.classList.add('hidden'); // New
            if (settingsSection) settingsSection.classList.add('hidden'); // New
            if (newPlayerSetupSection) newPlayerSetupSection.classList.add('hidden'); // New
            if (telegramOnlyMessage) telegramOnlyMessage.classList.add('hidden'); // Ensure this is also hidden

            // Show the desired section by removing 'hidden' class
            if (sectionToShow) sectionToShow.classList.remove('hidden');
            console.log(`Section ${sectionToShow.id} visibility: ${sectionToShow ? !sectionToShow.classList.contains('hidden') : 'N/A'}`);

            // Special handling for Dashboard to refresh data
            if (sectionToShow === dashboardSection) {
                fetchLeaderboard();
            }
        }


        // UI Elements (Declared with let and assigned in DOMContentLoaded)
        let loadingOverlay;
        let telegramOnlyMessage;
        let referralInputSection; // Old referral input
        let referralCodeInput;
        let startGameBtn;

        let newPlayerSetupSection; // New initial setup screen
        let initialUsernameInput;
        let initialReferralCodeInput;
        let startNewGameBtn;

        let gameWrapper;
        let gameSection;
        let userIdDisplay;
        let coinsDisplay;
        let energyDisplay;
        let energyBarFill;
        let tapArea;
        let dailyRewardBtn;
        
        let upgradesSection;
        let miningSection;
        let referralsSection;
        let redeemSection;
        let membershipSection;
        let dashboardSection; // New
        let settingsSection; // New
        
        let closeUpgradesBtn;
        let closeMiningBtn;
        let closeReferralsBtn;
        let closeRedeemBtn;
        let closeMembershipBtn;
        let closeDashboardBtn; // New
        let closeSettingsBtn; // New
        
        let messageBox;
        let messageText;

        let tapPowerLevel;
        let tapPowerIncrease;
        let tapPowerCost;
        let energyCapacityLevel;
        let energyCapacityIncrease;
        let energyCapacityCost;
        let energyRegenLevel;
        let energyRegenIncrease;
        let energyRegenCost;
        let upgradeTapPowerBtn;
        let upgradeEnergyCapacityBtn;
        let upgradeEnergyRegenBtn;

        let hourlyProfitDisplay;
        let accumulatedProfitDisplay;
        let claimProfitBtn;
        let cardsList;

        let playerLevelDisplay;
        let playerXpDisplay;
        let nextLevelXpDisplay;
        let xpProgressBar;
        let levelRewardInfo;
        let nextLevelRewardDisplay;
        let referralLinkDisplay;
        let copyReferralLinkBtn;
        let referredCountDisplay;

        let redeemReferralsTask;
        let redeemCoinsTask;
        let redeemCoinsBtn;
        let redeemStatusMessage;

        let navHomeBtn;
        let navUpgradesBtn;
        let navMinesBtn;
        let navReferralsBtn;
        let navRedeemBtn;
        let navMembershipBtn;
        let navDashboardBtn; // New
        let navSettingsBtn; // New

        let usernameInput;
        let saveUsernameBtn;
        let leaderboardList;

        let hamburgerMenuBtn;
        let sidebar;
        let sidebarOverlay;


        // Global variables for Firebase config and app ID
        // HARDCODED FOR DEBUGGING - REMOVE THIS BLOCK AND USE VERCEL ENV VARS FOR PRODUCTION
        const appId = 'smkvmk-f9b65'; // Using projectId as appId for simplicity in debugging
        const firebaseConfig = {
          apiKey: "AIzaSyANRGHTMawNZKQZiXh4zw84DTsB4hNODAs",
          authDomain: "smkvmk-f9b65.firebaseapp.com",
          projectId: "smkvmk-f9b65",
          storageBucket: "smkvmk-f9b65.firebasestorage.app",
          messagingSenderId: "372105939543",
          appId: "1:372105939543:web:3d836492ec1e748b313112",
          measurementId: "G-F8WBFFSP4M"
        };
        console.log("Firebase Config (hardcoded):", firebaseConfig);
        // END HARDCODED DEBUGGING SECTION


        // Initialize Firebase
        let app;
        let db;
        let auth;

        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            console.log("Firebase initialized successfully.");
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            // Fallback UI for Firebase init failure
            // This needs to be called after UI elements are assigned in DOMContentLoaded
            // This part will now be handled inside DOMContentLoaded block
            throw error; // Stop further execution
        }

        let userId = null;
        let gameDataRef = null;
        let unsubscribeSnapshot = null; // To store the unsubscribe function for onSnapshot
        let energyRegenInterval = null; // To store the interval ID for energy regen
        let passiveIncomeInterval = null; // To store the interval ID for passive income

        // Game State
        let gameState = {
            coins: 0,
            energy: 1000,
            maxEnergy: 1000,
            energyRegenRate: 1, // energy per second
            coinsPerTap: 1, // Base value, will be overridden by bonus or upgrades
            lastDailyRewardClaim: 0, // Unix timestamp in milliseconds
            upgradeLevels: {
                tapPower: 0,
                energyCapacity: 0,
                energyRegen: 0
            },
            hourlyProfit: 0,
            ownedCards: {}, // { cardId: level }
            lastProfitCalculationTime: Date.now(), // Timestamp for passive income calculation
            accumulatedProfit: 0,
            // New fields for levels and referrals
            level: 1, // Start at level 1
            xp: 0, // Experience points (total coins earned)
            referredBy: null, // userId of the referrer, if any
            referredCount: 0, // Number of users this player has successfully referred
            initialReferralBonusClaimed: false, // To ensure a user only gets the bonus once
            isRedeemed: false, // New: to track if redemption has been done
            referralCode: null, // New: Unique random referral code for this user
            username: null // New: User's chosen username
        };

        const ONE_CRORE_COINS = 10000000; // Define 1 crore for clarity

        // Upgrade Costs and Increments (can be adjusted for game balance)
        const UPGRADE_CONFIG = {
            tapPower: {
                baseCost: 100,
                costMultiplier: 1.5,
                increment: 1
            },
            energyCapacity: {
                baseCost: 200,
                costMultiplier: 1.6,
                increment: 100
            },
            energyRegen: {
                baseCost: 300,
                costMultiplier: 1.7,
                increment: 0.1
            }
        };

        // Card Configurations (Updated to be more like Hamster Kombat categories)
        const CARD_CONFIG = {
            'basic_miner': { // Renamed from defi_trading for initial tier
                name: 'Basic Miner',
                icon: '<i class="fas fa-pickaxe"></i>',
                baseCost: 500,
                costMultiplier: 1.8,
                baseProfitPerHour: 10,
                profitMultiplier: 1.2,
                maxLevel: 10,
                unlockedBy: null // Available from start
            },
            'defi_trading': {
                name: 'DeFi Trading',
                icon: '<i class="fas fa-chart-line"></i>',
                baseCost: 1500, // Adjusted cost
                costMultiplier: 2.0,
                baseProfitPerHour: 50, // Adjusted profit
                profitMultiplier: 1.3,
                maxLevel: 8,
                unlockedBy: { cardId: 'basic_miner', level: 3 } // Requires Basic Miner Lv. 3
            },
            'influencer_marketing': {
                name: 'Influencer Marketing',
                icon: '<i class="fas fa-bullhorn"></i>',
                baseCost: 3000,
                costMultiplier: 1.9,
                baseProfitPerHour: 100,
                profitMultiplier: 1.4,
                maxLevel: 7,
                unlockedBy: { cardId: 'defi_trading', level: 2 } // Requires DeFi Trading Lv. 2
            },
            'kyc_compliance': {
                name: 'KYC Compliance',
                icon: '<i class="fas fa-user-check"></i>',
                baseCost: 6000,
                costMultiplier: 1.8,
                baseProfitPerHour: 200,
                profitMultiplier: 1.5,
                maxLevel: 6,
                unlockedBy: { cardId: 'influencer_marketing', level: 3 } // Requires Influencer Marketing Lv. 3
            },
            'web3_academy': {
                name: 'Web3 Academy',
                icon: '<i class="fas fa-graduation-cap"></i>',
                baseCost: 10000,
                costMultiplier: 1.7,
                baseProfitPerHour: 350,
                profitMultiplier: 1.6,
                maxLevel: 5,
                unlockedBy: { cardId: 'kyc_compliance', level: 2 } // Requires KYC Compliance Lv. 2
            },
            'liquidity_pool': {
                name: 'Liquidity Pool',
                icon: '<i class="fas fa-water"></i>',
                baseCost: 20000,
                costMultiplier: 1.6,
                baseProfitPerHour: 600,
                profitMultiplier: 1.7,
                maxLevel: 4,
                unlockedBy: { cardId: 'web3_academy', level: 3 } // Requires Web3 Academy Lv. 3
            },
            'security_audit': {
                name: 'Security Audit',
                icon: '<i class="fas fa-shield-alt"></i>',
                baseCost: 35000,
                costMultiplier: 1.5,
                baseProfitPerHour: 1000,
                profitMultiplier: 1.8,
                maxLevel: 3,
                unlockedBy: { cardId: 'liquidity_pool', level: 2 } // Requires Liquidity Pool Lv. 2
            }
        };

        // Level Configuration (New)
        const LEVEL_CONFIG = [
            { level: 1, xpNeeded: 0, reward: 0 },
            { level: 2, xpNeeded: 1000, reward: 200 },
            { level: 3, xpNeeded: 3000, reward: 500 },
            { level: 4, xpNeeded: 7000, reward: 1000 },
            { level: 5, xpNeeded: 15000, reward: 2000 },
            { level: 6, xpNeeded: 30000, reward: 4000 },
            { level: 7, xpNeeded: 60000, reward: 8000 },
            { level: 8, xpNeeded: 120000, reward: 15000 },
            { level: 9, xpNeeded: 250000, reward: 30000 },
            { level: 10, xpNeeded: 500000, reward: 60000 }
        ];
        const REFERRAL_BONUS_NEW_USER = 1000; // Coins for the new user joining via link
        const REFERRAL_BONUS_REFERRER = 500; // Coins for the referrer (per successful referral) - currently not implemented as direct bonus, only count.

        // Redeem Configuration (New)
        const REDEEM_REQUIREMENTS = {
            referrals: 15,
            xp: 240000000, // 24 Crores XP (Total Coins Earned)
            reward: 10000000 // 10 Million coins as reward for redemption
        };

        /**
         * Displays a temporary message to the user.
         * @param {string} message The message to display.
         * @param {string} type The type of message (e.g., 'success', 'error', 'info').
         */
        function showMessage(message, type = 'info') {
            // Ensure messageBox and messageText are available
            if (!messageBox || !messageText) {
                console.error("showMessage called before messageBox/messageText are initialized:", message);
                return;
            }

            messageText.textContent = message;
            messageBox.className = 'fixed top-4 left-1/2 -translate-x-1/2 px-6 py-3 rounded-lg shadow-lg z-50 message-box'; // Reset animation
            messageBox.classList.remove('hidden');

            // Apply type-specific styling
            if (type === 'success') {
                messageBox.classList.add('bg-green-600', 'text-white');
            } else if (type === 'error') {
                messageBox.classList.add('bg-red-600', 'text-white');
            } else {
                messageBox.classList.add('bg-gray-800', 'text-white');
            }

            // Re-trigger animation
            void messageBox.offsetWidth; // Trigger reflow to restart animation
            messageBox.classList.add('message-box');

            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 3000); // Hide after 3 seconds
        }

        /**
         * Calculates the cost of the next level of an upgrade.
         * @param {string} upgradeType The type of upgrade (e.g., 'tapPower').
         * @returns {number} The cost of the next upgrade level.
         */
        function calculateUpgradeCost(upgradeType) {
            const config = UPGRADE_CONFIG[upgradeType];
            const currentLevel = gameState.upgradeLevels[upgradeType];
            return Math.floor(config.baseCost * Math.pow(config.costMultiplier, currentLevel));
        }

        /**
         * Calculates the cost of the next level of a card.
         * @param {string} cardId The ID of the card.
         * @returns {number} The cost of the next card level.
         */
        function calculateCardCost(cardId) {
            const config = CARD_CONFIG[cardId];
            const currentLevel = gameState.ownedCards[cardId] || 0;
            return Math.floor(config.baseCost * Math.pow(config.costMultiplier, currentLevel));
        }

        /**
         * Calculates the profit per hour for a specific card at a given level.
         * @param {string} cardId The ID of the card.
         * @param {number} level The level of the card.
         * @returns {number} The profit per hour for the card.
         */
        function calculateCardProfitPerHour(cardId, level) {
            const config = CARD_CONFIG[cardId];
            // Level 0 means no profit, level 1 is base profit
            return level > 0 ? config.baseProfitPerHour * Math.pow(config.profitMultiplier, level - 1) : 0;
        }

        /**
         * Recalculates the total hourly profit from all owned cards.
         */
        function recalculateHourlyProfit() {
            let totalProfit = 0;
            for (const cardId in CARD_CONFIG) { // Iterate through all possible cards
                const level = gameState.ownedCards[cardId] || 0; // Get level, default to 0 if not owned
                if (level > 0) { // Only add profit if card is owned (level > 0)
                    totalProfit += calculateCardProfitPerHour(cardId, level);
                }
            }
            gameState.hourlyProfit = totalProfit;
        }

        /**
         * Checks if the player can level up and applies rewards. (New)
         */
        async function checkLevelUp() {
            const nextLevelData = LEVEL_CONFIG.find(l => l.level === gameState.level + 1);

            if (nextLevelData && gameState.xp >= nextLevelData.xpNeeded) {
                gameState.level = nextLevelData.level;
                gameState.coins += nextLevelData.reward;
                showMessage(`Leveled up to Level ${gameState.level}! Received ${nextLevelData.reward} coins!`, 'success');
                updateUI();
                await saveGameState(); // Save immediately after level up
                checkLevelUp(); // Check for consecutive level-ups
            }
        }

        /**
         * Updates the UI elements based on the current game state.
         */
        function updateUI() {
            if (coinsDisplay) coinsDisplay.textContent = Math.floor(gameState.coins);
            if (energyDisplay) energyDisplay.textContent = `${Math.floor(gameState.energy)} / ${Math.floor(gameState.maxEnergy)}`;
            if (energyBarFill) energyBarFill.style.width = `${(gameState.energy / gameState.maxEnergy) * 100}%`;

            // Update upgrade section UI
            if (tapPowerLevel) tapPowerLevel.textContent = `(Lv. ${gameState.upgradeLevels.tapPower})`;
            if (tapPowerIncrease) tapPowerIncrease.textContent = UPGRADE_CONFIG.tapPower.increment;
            if (tapPowerCost) tapPowerCost.textContent = calculateUpgradeCost('tapPower');

            if (energyCapacityLevel) energyCapacityLevel.textContent = `(Lv. ${gameState.upgradeLevels.energyCapacity})`;
            if (energyCapacityIncrease) energyCapacityIncrease.textContent = UPGRADE_CONFIG.energyCapacity.increment;
            if (energyCapacityCost) energyCapacityCost.textContent = calculateUpgradeCost('energyCapacity');

            if (energyRegenLevel) energyRegenLevel.textContent = `(Lv. ${gameState.upgradeLevels.energyRegen})`;
            if (energyRegenIncrease) energyRegenIncrease.textContent = UPGRADE_CONFIG.energyRegen.increment.toFixed(1);
            if (energyRegenCost) energyRegenCost.textContent = calculateUpgradeCost('energyRegen');

            // Disable upgrade buttons if not enough coins
            if (upgradeTapPowerBtn) upgradeTapPowerBtn.disabled = gameState.coins < calculateUpgradeCost('tapPower');
            if (upgradeEnergyCapacityBtn) upgradeEnergyCapacityBtn.disabled = gameState.coins < calculateUpgradeCost('energyCapacity');
            if (upgradeEnergyRegenBtn) upgradeEnergyRegenBtn.disabled = gameState.coins < calculateUpgradeCost('energyRegen');

            // Update mining section UI
            if (hourlyProfitDisplay) hourlyProfitDisplay.textContent = Math.floor(gameState.hourlyProfit);
            if (accumulatedProfitDisplay) accumulatedProfitDisplay.textContent = Math.floor(gameState.accumulatedProfit);
            if (claimProfitBtn) claimProfitBtn.disabled = gameState.accumulatedProfit <= 0;

            // Render cards dynamically
            if (cardsList) {
                cardsList.innerHTML = ''; // Clear existing cards
                for (const cardId in CARD_CONFIG) {
                    const card = CARD_CONFIG[cardId];
                    const currentLevel = gameState.ownedCards[cardId] || 0;
                    const nextCost = calculateCardCost(cardId);
                    const currentProfit = calculateCardProfitPerHour(cardId, currentLevel);
                    const nextProfit = calculateCardProfitPerHour(cardId, currentLevel + 1);
                    const isMaxLevel = currentLevel >= card.maxLevel;

                    let isLocked = false;
                    let lockMessage = '';
                    if (card.unlockedBy) {
                        const prerequisiteCardLevel = gameState.ownedCards[card.unlockedBy.cardId] || 0;
                        if (prerequisiteCardLevel < card.unlockedBy.level) {
                            isLocked = true;
                            const prerequisiteCardName = CARD_CONFIG[card.unlockedBy.cardId] ? CARD_CONFIG[card.unlockedBy.cardId].name : 'Previous Card';
                            lockMessage = `Requires ${prerequisiteCardName} Lv. ${card.unlockedBy.level}`;
                        }
                    }

                    const cardElement = document.createElement('div');
                    cardElement.classList.add('flex', 'items-center', 'justify-between', 'bg-gray-800', 'p-4', 'rounded-lg', 'shadow-md');
                    if (isLocked) { // Only add opacity-50 if locked
                        cardElement.classList.add('opacity-50');
                    }
                    cardElement.innerHTML = `
                        <div>
                            <h3 class="font-semibold text-lg ${isLocked ? 'text-gray-500' : 'text-purple-400'}">${card.icon} ${card.name} <span class="text-gray-400">(Lv. ${currentLevel})</span></h3>
                            <p class="text-sm text-gray-300">Profit/hr: ${Math.floor(currentProfit)} <span class="text-green-400">${isMaxLevel || isLocked ? '' : `-> ${Math.floor(nextProfit)}`}</span></p>
                            ${isLocked ? `<p class="text-xs text-red-400">${lockMessage}</p>` : ''}
                        </div>
                        <button id="buy-card-${cardId}" class="btn-primary py-2 px-4 rounded-lg text-sm font-bold ${isMaxLevel || isLocked ? 'opacity-50 cursor-not-allowed' : ''}" ${isMaxLevel || isLocked ? 'disabled' : ''}>
                            ${isMaxLevel ? 'Max Level' : (isLocked ? 'Locked' : `Buy (${nextCost} <i class="fas fa-coins"></i>)`)}
                        </button>
                    `;
                    cardsList.appendChild(cardElement);

                    // Add event listener for the buy button
                    if (!isMaxLevel && !isLocked) {
                        const buyButton = cardElement.querySelector(`#buy-card-${cardId}`);
                        if (buyButton) buyButton.disabled = gameState.coins < nextCost;
                        if (buyButton) buyButton.addEventListener('click', () => purchaseCard(cardId));
                    }
                }
            }


            // Update Settings UI (New)
            if (playerLevelDisplay) playerLevelDisplay.textContent = gameState.level;
            if (playerXpDisplay) playerXpDisplay.textContent = Math.floor(gameState.xp);
            const nextLevelData = LEVEL_CONFIG.find(l => l.level === gameState.level + 1);
            if (nextLevelData) {
                if (nextLevelXpDisplay) nextLevelXpDisplay.textContent = nextLevelData.xpNeeded;
                if (xpProgressBar) xpProgressBar.style.width = `${(gameState.xp / nextLevelData.xpNeeded) * 100}%`;
                if (nextLevelRewardDisplay) nextLevelRewardDisplay.textContent = nextLevelData.reward;
                if (levelRewardInfo) levelRewardInfo.classList.remove('hidden');
            } else {
                if (nextLevelXpDisplay) nextLevelXpDisplay.textContent = 'MAX';
                if (xpProgressBar) xpProgressBar.style.width = '100%';
                if (levelRewardInfo) levelRewardInfo.classList.add('hidden'); // Hide reward info if max level
            }

            // Referral Link
            if (referralLinkDisplay) {
                if (userId && gameState.referralCode) { // Use gameState.referralCode
                    const currentUrl = window.location.origin + window.location.pathname;
                    referralLinkDisplay.textContent = `${currentUrl}?ref=${gameState.referralCode}`;
                } else {
                    referralLinkDisplay.textContent = 'Loading...';
                }
            }
            if (referredCountDisplay) referredCountDisplay.textContent = gameState.referredCount;

            // Update Redeem Section UI (New)
            if (redeemReferralsTask) redeemReferralsTask.textContent = `${gameState.referredCount} / ${REDEEM_REQUIREMENTS.referrals} Referrals`;
            if (redeemCoinsTask) redeemCoinsTask.textContent = `${Math.floor(gameState.xp)} / ${REDEEM_REQUIREMENTS.xp.toLocaleString()} Total Coins Earned (XP)`;
            if (redeemCoinsBtn) redeemCoinsBtn.textContent = `Redeem Coins (Reward: ${REDEEM_REQUIREMENTS.reward.toLocaleString()})`;

            const canRedeem = gameState.referredCount >= REDEEM_REQUIREMENTS.referrals &&
                             gameState.xp >= REDEEM_REQUIREMENTS.xp &&
                             !gameState.isRedeemed; // Can only redeem once

            if (redeemCoinsBtn) redeemCoinsBtn.disabled = !canRedeem;
            if (redeemCoinsBtn) {
                if (canRedeem) {
                    redeemCoinsBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    if (redeemStatusMessage) redeemStatusMessage.classList.add('hidden');
                } else {
                    redeemCoinsBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    if (redeemStatusMessage) {
                        redeemStatusMessage.classList.remove('hidden');
                        if (gameState.isRedeemed) {
                            redeemStatusMessage.textContent = "Reward already redeemed!";
                        } else if (gameState.referredCount < REDEEM_REQUIREMENTS.referrals && gameState.xp < REDEEM_REQUIREMENTS.xp) {
                            redeemStatusMessage.textContent = "Tasks not completed yet.";
                        } else if (gameState.referredCount < REDEEM_REQUIREMENTS.referrals) {
                            redeemStatusMessage.textContent = `Need ${REDEEM_REQUIREMENTS.referrals - gameState.referredCount} more referrals.`;
                        } else if (gameState.xp < REDEEM_REQUIREMENTS.xp) {
                            redeemStatusMessage.textContent = `Need ${(REDEEM_REQUIREMENTS.xp - gameState.xp).toLocaleString()} more XP.`;
                        }
                    }
                }
            }

            // Update Username in Settings
            if (usernameInput) usernameInput.value = gameState.username || '';
        }

        /**
         * Saves the current game state to Firestore.
         */
        async function saveGameState() {
            if (gameDataRef) {
                try {
                    // Update lastProfitCalculationTime before saving
                    gameState.lastProfitCalculationTime = Date.now();
                    await setDoc(gameDataRef, gameState);
                    console.log("Game state saved successfully!");
                } catch (error) {
                    console.error("Error saving game state:", error);
                    showMessage("Error saving game progress.", 'error');
                }
            }
        }

        /**
         * Handles the tapping action.
         * @param {Event} touch The individual touch object.
         */
        function handleTap(touch) { // Changed parameter from event to touch
            console.log("Tap processed!"); // Log for each individual tap
            // Energy cost is always 1 per tap (per finger)
            if (gameState.energy >= 1) { // Check if there's at least 1 energy for a tap
                const earned = gameState.coinsPerTap; // Use the current coinsPerTap value
                gameState.coins += earned;
                gameState.xp += earned; // XP from tapping
                gameState.energy -= 1; // Energy cost for tap is always 1

                updateUI();
                saveGameState(); // Save on every tap for responsiveness
                checkLevelUp(); // Check for level up after earning coins

                // Show coin popup animation at the touch point
                const tapRect = tapArea.getBoundingClientRect();
                const x = touch.clientX - tapRect.left; // Use touch.clientX
                const y = touch.clientY - tapRect.top; // Use touch.clientY

                const coinPopup = document.createElement('div');
                coinPopup.textContent = `+${earned}`;
                coinPopup.classList.add('coin-popup');
                coinPopup.style.left = `${x}px`;
                coinPopup.style.top = `${y}px`;
                tapArea.appendChild(coinPopup);

                coinPopup.addEventListener('animationend', () => {
                    coinPopup.remove();
                });
            } else {
                showMessage("Not enough energy!", 'error');
            }
        }

        /**
         * Handles daily reward claim.
         */
        function claimDailyReward() {
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

            if (now - gameState.lastDailyRewardClaim >= twentyFourHours) {
                const rewardAmount = 500; // Example reward
                gameState.coins += rewardAmount;
                gameState.xp += rewardAmount; // XP from daily reward
                gameState.lastDailyRewardClaim = now;
                showMessage(`Claimed daily reward: +${rewardAmount} coins!`, 'success');
                updateUI();
                saveGameState();
                checkLevelUp(); // Check for level up after earning coins
            } else {
                const timeRemaining = twentyFourHours - (now - gameState.lastDailyRewardClaim);
                const hours = Math.floor((timeRemaining / (1000 * 60 * 60)));
                const minutes = Math.floor(((timeRemaining % (1000 * 60 * 60)) / (1000 * 60)));
                const seconds = Math.floor(((timeRemaining % (1000 * 60)) / 1000));
                showMessage(`Next daily reward in: ${hours}h ${minutes}m ${seconds}s`, 'info');
            }
        }

        /**
         * Handles upgrade purchases.
         * @param {string} upgradeType The type of upgrade to purchase.
         */
        function purchaseUpgrade(upgradeType) {
            const cost = calculateUpgradeCost(upgradeType);
            const config = UPGRADE_CONFIG[upgradeType];

            if (gameState.coins >= cost) {
                gameState.coins -= cost;
                gameState.upgradeLevels[upgradeType]++;

                if (upgradeType === 'tapPower') {
                    // Tap Power upgrade now directly increases coinsPerTap
                    gameState.coinsPerTap += config.increment;
                } else if (upgradeType === 'energyCapacity') {
                    gameState.maxEnergy += config.increment;
                    // Also fill energy to new max when capacity increases
                    gameState.energy = Math.min(gameState.energy + config.increment, gameState.maxEnergy);
                } else if (upgradeType === 'energyRegen') {
                    gameState.energyRegenRate += config.increment;
                }

                showMessage(`${upgradeType.replace(/([A-Z])/g, ' $1')} upgraded to Lv. ${gameState.upgradeLevels[upgradeType]}!`, 'success');
                updateUI();
                saveGameState();
            } else {
                showMessage("Not enough coins for this upgrade!", 'error');
            }
        }

        /**
         * Handles card purchases.
         * @param {string} cardId The ID of the card to purchase.
         */
        function purchaseCard(cardId) {
            const cost = calculateCardCost(cardId);
            const cardConfig = CARD_CONFIG[cardId];
            const currentLevel = gameState.ownedCards[cardId] || 0;

            // Check if card is at max level
            if (currentLevel >= cardConfig.maxLevel) {
                showMessage(`This card is already at max level (${cardConfig.maxLevel}).`, 'info');
                return;
            }

            // Check prerequisites for unlocking
            if (cardConfig.unlockedBy) {
                const prerequisiteCardLevel = gameState.ownedCards[cardConfig.unlockedBy.cardId] || 0;
                if (prerequisiteCardLevel < cardConfig.unlockedBy.level) {
                    const prerequisiteCardName = CARD_CONFIG[cardConfig.unlockedBy.cardId] ? CARD_CONFIG[cardConfig.unlockedBy.cardId].name : 'Previous Card';
                    showMessage(`Unlock failed: Requires ${prerequisiteCardName} Lv. ${cardConfig.unlockedBy.level}.`, 'error');
                    return;
                }
            }

            if (gameState.coins >= cost) {
                gameState.coins -= cost;
                gameState.ownedCards[cardId] = (gameState.ownedCards[cardId] || 0) + 1;
                recalculateHourlyProfit(); // Recalculate profit after buying a card
                showMessage(`${cardConfig.name} upgraded to Lv. ${gameState.ownedCards[cardId]}!`, 'success');
                updateUI();
                saveGameState();
            } else {
                showMessage("Not enough coins for this card!", 'error');
            }
        }

        /**
         * Updates accumulated profit based on time elapsed.
         */
        function updateAccumulatedProfit() {
            const now = Date.now();
            const timeElapsed = now - gameState.lastProfitCalculationTime; // in milliseconds

            if (timeElapsed > 0 && gameState.hourlyProfit > 0) {
                // Convert hourly profit to profit per millisecond
                const profitPerMs = gameState.hourlyProfit / (60 * 60 * 1000);
                const profitToAdd = profitPerMs * timeElapsed;
                gameState.accumulatedProfit += profitToAdd;
            }
            gameState.lastProfitCalculationTime = now;
            updateUI(); // Update UI to show accumulated profit
        }

        /**
         * Claims all accumulated passive profit.
         */
        function claimAccumulatedProfit() {
            if (gameState.accumulatedProfit > 0) {
                const claimedAmount = Math.floor(gameState.accumulatedProfit);
                gameState.coins += claimedAmount;
                gameState.xp += claimedAmount; // XP from passive profit
                showMessage(`Claimed ${claimedAmount} passive coins!`, 'success');
                gameState.accumulatedProfit = 0;
                updateUI();
                saveGameState();
                checkLevelUp(); // Check for level up after earning coins
            } else {
                showMessage("No passive profit to claim.", 'info');
            }
        }

        /**
         * Starts the energy regeneration and passive income loops.
         */
        function startGameLoops() {
            if (!energyRegenInterval) {
                energyRegenInterval = setInterval(() => {
                    if (gameState.energy < gameState.maxEnergy) {
                        gameState.energy = Math.min(gameState.maxEnergy, gameState.energy + gameState.energyRegenRate);
                        updateUI();
                    }
                }, 1000); // Regenerate every second
            }

            if (!passiveIncomeInterval) {
                passiveIncomeInterval = setInterval(() => {
                    updateAccumulatedProfit();
                }, 1000); // Check and update accumulated profit every second
            }
        }

        /**
         * Stops the energy regeneration and passive income loops.
         */
        function stopGameLoops() {
            if (energyRegenInterval) {
                clearInterval(energyRegenInterval);
                energyRegenInterval = null;
            }
            if (passiveIncomeInterval) {
                clearInterval(passiveIncomeInterval);
                passiveIncomeInterval = null;
            }
        }

        /**
         * Handles the redemption process. (New)
         */
        async function handleRedeem() {
            console.log("Redeem button clicked!");
            if (gameState.isRedeemed) {
                showMessage("Reward already redeemed!", 'info');
                return;
            }

            const referralsMet = gameState.referredCount >= REDEEM_REQUIREMENTS.referrals;
            const coinsMet = gameState.xp >= REDEEM_REQUIREMENTS.xp;

            if (referralsMet && coinsMet) {
                gameState.coins += REDEEM_REQUIREMENTS.reward;
                gameState.xp += REDEEM_REQUIREMENTS.reward; // XP for redemption reward
                gameState.isRedeemed = true;
                showMessage(`Redeemed! You received ${REDEEM_REQUIREMENTS.reward.toLocaleString()} coins!`, 'success');
                updateUI();
                await saveGameState();
                checkLevelUp();
            } else {
                let message = "You have not met all redemption requirements:";
                if (!referralsMet) {
                    message += ` Need ${REDEEM_REQUIREMENTS.referrals - gameState.referredCount} more referrals.`;
                }
                if (!coinsMet) {
                    message += ` Need ${(REDEEM_REQUIREMENTS.xp - gameState.xp).toLocaleString()} more XP.`;
                }
                showMessage(message, 'error');
            }
        }

        /**
         * Generates a random alphanumeric code.
         * @param {number} length The desired length of the code.
         * @returns {string} The generated random code.
         */
        function generateRandomCode(length) {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            const charactersLength = characters.length;
            for (let i = 0; i < length; i++) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
            }
            return result;
        }

        /**
         * Initializes a new user's game state after referral input (or no referral).
         * @param {string|null} enteredReferralCode The referral code entered by the new user, or null if none.
         * @param {string} newUsername The username entered by the new user.
         */
        async function initializeNewUserGame(enteredReferralCode, newUsername) {
            console.log(`Initializing new user game for ID: ${userId} with username: ${newUsername} and entered referral code: ${enteredReferralCode}`);
            gameState.lastProfitCalculationTime = Date.now();
            gameState.coinsPerTap = 1; // Base value for new user
            gameState.username = newUsername; // Set username for new user

            // Generate a random referral code for the new user
            gameState.referralCode = generateRandomCode(8); // 8-character random code

            let referrerUserId = null;
            if (enteredReferralCode) {
                try {
                    // Query Firestore to find the user with this referral code
                    const usersRef = collection(db, `artifacts/${appId}/users`);
                    const q = query(usersRef, where("referralCode", "==", enteredReferralCode));
                    const querySnapshot = await getDocs(q);

                    if (!querySnapshot.empty) {
                        // Found the referrer
                        referrerUserId = querySnapshot.docs[0].id; // Get the actual userId of the referrer
                        console.log(`Referral code '${enteredReferralCode}' matched to referrer userId: ${referrerUserId}`);
                        
                        // Check if the referrer is not the new user themselves
                        if (referrerUserId === userId) {
                            showMessage("You cannot refer yourself!", 'error');
                            referrerUserId = null; // Invalidate self-referral
                        } else {
                            gameState.referredBy = referrerUserId;
                            gameState.coins += REFERRAL_BONUS_NEW_USER;
                            gameState.xp += REFERRAL_BONUS_NEW_USER; // XP for referral bonus
                            gameState.initialReferralBonusClaimed = true;
                            showMessage(`Welcome bonus! +${REFERRAL_BONUS_NEW_USER} coins for joining via a referral!`, 'success');
                            console.log(`New user bonus applied. Referred by: ${referrerId}`);
                        }
                    } else {
                        showMessage("Invalid referral code entered.", 'error');
                        console.warn(`Referral code '${enteredReferralCode}' not found.`);
                    }
                } catch (error) {
                    console.error("Error looking up referrer by code:", error);
                    showMessage("Error validating referral code. Please try again.", 'error');
                }
            }

            await setDoc(gameDataRef, gameState)
                .then(() => console.log("Initial game state set successfully."))
                .catch(error => console.error("Error setting initial game state:", error));

            // If a referrer exists, attempt to increment their count
            if (referrerUserId) { // Use referrerUserId obtained from lookup
                try {
                    const referrerGameDataRef = doc(db, `artifacts/${appId}/users/${referrerUserId}/hamster_coin_game`, 'game_state');
                    await updateDoc(referrerGameDataRef, {
                        referredCount: increment(1)
                    });
                    console.log(`Referrer (${referrerUserId}) count incremented.`);
                } catch (error) {
                    console.warn(`Could not increment referrer (${referrerUserId}) count:`, error);
                    showMessage("Could not update referrer's count (Firebase rules might be too strict or referrer doesn't exist).", 'info');
                }
            }

            recalculateHourlyProfit();
            updateUI();
            window.showSection(gameSection); // Show the main game section
            loadingOverlay.classList.add('hidden');
            startGameLoops();
            console.log("New game initialized and UI updated.");
            checkLevelUp();
        }


        /**
         * Loads game data for a given user ID.
         * @param {string} id The user ID to load data for.
         */
        async function loadGameData(id) {
            console.log(`Attempting to load game data for userId: ${id}`);
            userId = id; // Set global userId
            userIdDisplay.textContent = userId;
            gameDataRef = doc(db, `artifacts/${appId}/users/${userId}/hamster_coin_game`, 'game_state');

            stopGameLoops();
            if (unsubscribeSnapshot) {
                unsubscribeSnapshot();
                unsubscribeSnapshot = null;
            }

            try {
                unsubscribeSnapshot = onSnapshot(gameDataRef, async (docSnap) => {
                    console.log("Firestore onSnapshot callback fired.");
                    if (docSnap.exists()) {
                        const loadedState = docSnap.data();
                        gameState = {
                            ...gameState,
                            ...loadedState,
                            // Ensure new fields are initialized if old data doesn't have them
                            referralCode: loadedState.referralCode || generateRandomCode(8), // Generate if missing
                            isRedeemed: loadedState.isRedeemed || false,
                            referredBy: loadedState.referredBy || null,
                            referredCount: loadedState.referredCount || 0,
                            initialReferralBonusClaimed: loadedState.initialReferralBonusClaimed || false,
                            username: loadedState.username || null, // Initialize username
                            upgradeLevels: { ...loadedState.upgradeLevels || {} }, // Ensure nested objects are merged
                            ownedCards: { ...loadedState.ownedCards || {} } // Ensure nested objects are merged
                        };
                        console.log("Game state loaded/updated from Firestore:", gameState);

                        // If referralCode or username was just generated/missing for an old user, save it back
                        if (!loadedState.referralCode) { // Only save if referralCode was generated
                            await setDoc(gameDataRef, { referralCode: gameState.referralCode }, { merge: true });
                            console.log("Generated and saved referralCode for existing user.");
                        }
                        if (!loadedState.username) { // Only save if username was generated
                            await setDoc(gameDataRef, { username: gameState.username }, { merge: true });
                            console.log("Generated and saved username for existing user.");
                        }


                        const now = Date.now();
                        const timeElapsedOffline = now - (gameState.lastProfitCalculationTime || now);
                        if (timeElapsedOffline > 0 && gameState.hourlyProfit > 0) {
                            const profitPerMs = gameState.hourlyProfit / (60 * 60 * 1000);
                            const offlineProfit = profitPerMs * timeElapsedOffline;
                            gameState.accumulatedProfit += offlineProfit;
                            showMessage(`Welcome back! You earned ${Math.floor(offlineProfit)} coins while away.`, 'info');
                        }
                        gameState.lastProfitCalculationTime = now;
                        
                        // Ensure coinsPerTap is correctly set based on upgrades
                        gameState.coinsPerTap = 1 + (gameState.upgradeLevels.tapPower * UPGRADE_CONFIG.tapPower.increment);

                        recalculateHourlyProfit();
                        updateUI();
                        // If username is missing for an existing user, prompt them to set it
                        if (!gameState.username) {
                            console.log("Existing user has no username, prompting for setup.");
                            loadingOverlay.classList.add('hidden');
                            window.showSection(newPlayerSetupSection); // Re-use new player setup for username
                            initialReferralCodeInput.value = ''; // Clear referral code for existing user
                            initialReferralCodeInput.disabled = true; // Disable referral input
                            initialUsernameInput.placeholder = 'Enter your Username'; // Adjust placeholder
                            startNewGameBtn.textContent = 'Save Username & Start';
                            startNewGameBtn.onclick = () => { // Re-assign onclick for this specific flow
                                const enteredUsername = initialUsernameInput.value.trim();
                                if (enteredUsername) {
                                    gameState.username = enteredUsername;
                                    saveGameState(); // Save the new username
                                    window.showSection(gameSection); // Proceed to game
                                } else {
                                    showMessage("Please enter a username.", 'error');
                                }
                            };
                        } else {
                            window.showSection(gameSection); // Explicitly show game section after loading
                            loadingOverlay.classList.add('hidden'); // Hide loading overlay
                            startGameLoops(); // Start game loops only after data is ready
                            console.log("Game loaded and UI updated.");
                            checkLevelUp(); // Check level up on game load
                        }

                    } else {
                        // New user: Show referral/username input screen
                        console.log("No game state found in Firestore, new user. Showing setup input.");
                        loadingOverlay.classList.add('hidden');
                        window.showSection(newPlayerSetupSection); // Show new player setup section
                        
                        // Attach event listener for the Start Game button on the referral screen
                        startNewGameBtn.onclick = () => {
                            const enteredUsername = initialUsernameInput.value.trim();
                            if (!enteredUsername) {
                                showMessage("Please choose a username.", 'error');
                                return;
                            }
                            const enteredReferralCode = initialReferralCodeInput.value.trim();
                            initializeNewUserGame(enteredReferralCode || null, enteredUsername); // Pass username
                        };
                    }
                }, (error) => {
                    console.error("Error listening to game state (onSnapshot error callback):", error);
                    showMessage("Error loading game data. Please check your internet connection and Firebase rules.", 'error');
                    loadingOverlay.classList.add('hidden');
                    telegramOnlyMessage.classList.remove('hidden');
                    document.getElementById('telegram-only-message').innerHTML = `
                        <i class="fas fa-exclamation-triangle text-6xl text-red-400 mb-4"></i>
                        <h2 class="text-2xl font-bold text-red-400 mb-4">Data Loading Error</h2>
                        <p class="text-lg text-gray-300">Could not load your game data. This might be a network issue or Firebase security rules preventing access.</p>
                        <p class="text-md text-gray-400 mt-2">Error: ${error.message}</p>
                    `;
                });
            } catch (error) {
                console.error("Error setting up Firestore listener (try-catch block):", error);
                showMessage("Failed to set up game data listener. Please try again.", 'error');
                loadingOverlay.classList.add('hidden');
                telegramOnlyMessage.classList.remove('hidden');
                document.getElementById('telegram-only-message').innerHTML = `
                    <i class="fas fa-exclamation-triangle text-6xl text-red-400 mb-4"></i>
                    <h2 class="text-2xl font-bold text-red-400 mb-4">Game Setup Error</h2>
                    <p class="text-lg text-gray-300">An error occurred during game setup. Please try again later.</p>
                    <p class="text-md text-gray-400 mt-2">Error: ${error.message}</p>
                `;
            }
        }

        // Function to fetch and display leaderboard (New)
        async function fetchLeaderboard() {
            if (!leaderboardList) {
                console.warn("Leaderboard list element not found.");
                return;
            }
            leaderboardList.innerHTML = '<tr><td colspan="3" class="text-center py-4 text-gray-400">Loading leaderboard...</td></tr>';
            try {
                const usersCollectionRef = collection(db, `artifacts/${appId}/users`);
                // Order by xp descending, limit to 1000 players
                const q = query(usersCollectionRef, orderBy("hamster_coin_game.xp", "desc"), limit(1000));
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    leaderboardList.innerHTML = '<tr><td colspan="3" class="text-center py-4 text-gray-400">No players on the leaderboard yet.</td></tr>';
                    return;
                }

                let rank = 1;
                leaderboardList.innerHTML = ''; // Clear loading message
                querySnapshot.forEach((doc) => {
                    const playerData = doc.data().hamster_coin_game; // Access nested game_state
                    if (playerData && playerData.username && playerData.xp !== undefined) {
                        const row = `
                            <tr class="${rank % 2 === 0 ? 'bg-gray-700' : 'bg-gray-800'}">
                                <td class="px-4 py-2">${rank}.</td>
                                <td class="px-4 py-2">${playerData.username}</td>
                                <td class="px-4 py-2 text-right">${Math.floor(playerData.xp).toLocaleString()}</td>
                            </tr>
                        `;
                        leaderboardList.innerHTML += row;
                        rank++;
                    }
                });
            } catch (error) {
                console.error("Error fetching leaderboard:", error);
                leaderboardList.innerHTML = `<tr><td colspan="3" class="text-center py-4 text-red-400">Error loading leaderboard: ${error.message}</td></tr>`;
                showMessage("Failed to load leaderboard.", 'error');
            }
        }

        // Event listener for saving username (New)
        async function saveUsername() {
            const newUsername = usernameInput.value.trim();
            if (!newUsername) {
                showMessage("Username cannot be empty!", 'error');
                return;
            }
            if (newUsername === gameState.username) {
                showMessage("Username is already the same.", 'info');
                return;
            }

            try {
                await updateDoc(gameDataRef, { username: newUsername });
                gameState.username = newUsername; // Update local state
                showMessage("Username updated successfully!", 'success');
                updateUI(); // Refresh UI with new username
            } catch (error) {
                console.error("Error updating username:", error);
                showMessage(`Failed to update username: ${error.message}`, 'error');
            }
        }


        // Initial check for Telegram Web App on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded fired. Initializing...");
            // Assign ALL UI elements here to ensure they are available before any logic runs
            loadingOverlay = document.getElementById('loading-overlay');
            telegramOnlyMessage = document.getElementById('telegram-only-message');
            referralInputSection = document.getElementById('referral-input-section');
            referralCodeInput = document.getElementById('referral-code-input');
            startGameBtn = document.getElementById('start-game-btn');

            newPlayerSetupSection = document.getElementById('new-player-setup-section');
            initialUsernameInput = document.getElementById('initial-username-input');
            initialReferralCodeInput = document.getElementById('initial-referral-code-input');
            startNewGameBtn = document.getElementById('start-new-game-btn');

            gameWrapper = document.getElementById('game-wrapper');
            gameSection = document.getElementById('game-section');
            userIdDisplay = document.getElementById('user-id-display');
            coinsDisplay = document.getElementById('coins-display');
            energyDisplay = document.getElementById('energy-display');
            energyBarFill = document.getElementById('energy-bar-fill');
            tapArea = document.getElementById('tap-area');
            dailyRewardBtn = document.getElementById('daily-reward-btn');
            
            upgradesSection = document.getElementById('upgrades-section');
            miningSection = document.getElementById('mining-section');
            referralsSection = document.getElementById('referrals-section');
            redeemSection = document.getElementById('redeem-section');
            membershipSection = document.getElementById('membership-section');
            dashboardSection = document.getElementById('dashboard-section');
            settingsSection = document.getElementById('settings-section');
            
            closeUpgradesBtn = document.getElementById('close-upgrades-btn');
            closeMiningBtn = document.getElementById('close-mining-btn');
            closeReferralsBtn = document.getElementById('close-referrals-btn');
            closeRedeemBtn = document.getElementById('close-redeem-btn');
            closeMembershipBtn = document.getElementById('close-membership-btn');
            closeDashboardBtn = document.getElementById('close-dashboard-btn');
            closeSettingsBtn = document.getElementById('close-settings-btn');
            
            messageBox = document.getElementById('message-box');
            messageText = document.getElementById('message-text');

            tapPowerLevel = document.getElementById('tap-power-level');
            tapPowerIncrease = document.getElementById('tap-power-increase');
            tapPowerCost = document.getElementById('tap-power-cost');
            energyCapacityLevel = document.getElementById('energy-capacity-level');
            energyCapacityIncrease = document.getElementById('energy-capacity-increase');
            energyCapacityCost = document.getElementById('energy-capacity-cost');
            energyRegenLevel = document.getElementById('energy-regen-level');
            energyRegenIncrease = document.getElementById('energy-regen-increase');
            energyRegenCost = document.getElementById('energy-regen-cost');
            upgradeTapPowerBtn = document.getElementById('upgrade-tap-power');
            upgradeEnergyCapacityBtn = document.getElementById('upgrade-energy-capacity');
            upgradeEnergyRegenBtn = document.getElementById('upgrade-energy-regen');

            hourlyProfitDisplay = document.getElementById('hourly-profit-display');
            accumulatedProfitDisplay = document.getElementById('accumulated-profit-display');
            claimProfitBtn = document.getElementById('claim-profit-btn');
            cardsList = document.getElementById('cards-list');

            playerLevelDisplay = document.getElementById('player-level-display');
            playerXpDisplay = document.getElementById('player-xp-display');
            nextLevelXpDisplay = document.getElementById('next-level-xp-display');
            xpProgressBar = document.getElementById('xp-progress-bar');
            levelRewardInfo = document.getElementById('level-reward-info');
            nextLevelRewardDisplay = document.getElementById('next-level-reward-display');
            referralLinkDisplay = document.getElementById('referral-link-display');
            copyReferralLinkBtn = document.getElementById('copy-referral-link-btn');
            referredCountDisplay = document.getElementById('referred-count-display');

            redeemReferralsTask = document.getElementById('redeem-referrals-task');
            redeemCoinsTask = document.getElementById('redeem-coins-task');
            redeemCoinsBtn = document.getElementById('redeem-coins-btn');
            redeemStatusMessage = document.getElementById('redeem-status-message');

            // Corrected IDs for sidebar navigation buttons
            navHomeBtn = document.getElementById('sidebar-nav-home-btn');
            navUpgradesBtn = document.getElementById('sidebar-nav-upgrades-btn');
            navMinesBtn = document.getElementById('sidebar-nav-mines-btn');
            navReferralsBtn = document.getElementById('sidebar-nav-referrals-btn');
            navRedeemBtn = document.getElementById('sidebar-nav-redeem-btn');
            navMembershipBtn = document.getElementById('sidebar-nav-membership-btn');
            navDashboardBtn = document.getElementById('sidebar-nav-dashboard-btn');
            navSettingsBtn = document.getElementById('sidebar-nav-settings-btn');

            usernameInput = document.getElementById('username-input');
            saveUsernameBtn = document.getElementById('save-username-btn');
            leaderboardList = document.getElementById('leaderboard-list');

            hamburgerMenuBtn = document.getElementById('hamburger-menu-btn');
            sidebar = document.getElementById('sidebar');
            sidebarOverlay = document.getElementById('sidebar-overlay');


            loadingOverlay.classList.remove('hidden'); // Now safe to access

            // Attach Event Listeners after elements are assigned
            if (tapArea) { // Defensive check
                tapArea.addEventListener('touchstart', (event) => {
                    event.preventDefault(); // Prevent default browser touch behavior (like scrolling/zooming)
                    // Handle each touch individually
                    for (let i = 0; i < event.touches.length; i++) {
                        // Pass the individual touch object to handleTap
                        handleTap(event.touches[i]);
                    }
                });
            } else {
                console.error("tapArea element not found!");
            }


            if (dailyRewardBtn) dailyRewardBtn.addEventListener('click', claimDailyReward);

            // Sidebar/Navigation button listeners
            if (hamburgerMenuBtn) {
                hamburgerMenuBtn.addEventListener('click', () => {
                    if (sidebar) sidebar.classList.toggle('open');
                    if (sidebarOverlay) sidebarOverlay.classList.toggle('visible');
                });
            }
            if (sidebarOverlay) {
                sidebarOverlay.addEventListener('click', () => {
                    if (sidebar) sidebar.classList.remove('open');
                    if (sidebarOverlay) sidebarOverlay.classList.remove('visible');
                });
            }

            // Attach listeners to sidebar navigation buttons
            if (navHomeBtn) navHomeBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Nav Home clicked!"); showSection(gameSection); if(sidebar) sidebar.classList.remove('open'); if(sidebarOverlay) sidebarOverlay.classList.remove('visible'); });
            if (navUpgradesBtn) navUpgradesBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Nav Upgrades clicked!"); showSection(upgradesSection); if(sidebar) sidebar.classList.remove('open'); if(sidebarOverlay) sidebarOverlay.classList.remove('visible'); });
            if (navMinesBtn) navMinesBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Nav Mines clicked!"); showSection(miningSection); if(sidebar) sidebar.classList.remove('open'); if(sidebarOverlay) sidebarOverlay.classList.remove('visible'); });
            if (navReferralsBtn) navReferralsBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Nav Referrals clicked!"); showSection(referralsSection); if(sidebar) sidebar.classList.remove('open'); if(sidebarOverlay) sidebarOverlay.classList.remove('visible'); });
            if (navRedeemBtn) navRedeemBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Nav Redeem clicked!"); showSection(redeemSection); updateUI(); if(sidebar) sidebar.classList.remove('open'); if(sidebarOverlay) sidebarOverlay.classList.remove('visible'); });
            if (navMembershipBtn) navMembershipBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Nav Membership clicked!"); showSection(membershipSection); if(sidebar) sidebar.classList.remove('open'); if(sidebarOverlay) sidebarOverlay.classList.remove('visible'); });
            if (navDashboardBtn) navDashboardBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Nav Dashboard clicked!"); showSection(dashboardSection); if(sidebar) sidebar.classList.remove('open'); if(sidebarOverlay) sidebarOverlay.classList.remove('visible'); });
            if (navSettingsBtn) navSettingsBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Nav Settings clicked!"); showSection(settingsSection); updateUI(); if(sidebar) sidebar.classList.remove('open'); if(sidebarOverlay) sidebarOverlay.classList.remove('visible'); });


            if (closeUpgradesBtn) closeUpgradesBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Closing upgrades section!"); showSection(gameSection); });
            if (closeMiningBtn) closeMiningBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Closing mining section!"); showSection(gameSection); });
            if (closeReferralsBtn) closeReferralsBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Closing referrals section!"); showSection(gameSection); });
            if (closeRedeemBtn) closeRedeemBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Closing redeem section!"); showSection(gameSection); });
            if (closeMembershipBtn) closeMembershipBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Closing membership section!"); showSection(gameSection); });
            if (closeDashboardBtn) closeDashboardBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Closing dashboard section!"); showSection(gameSection); });
            if (closeSettingsBtn) closeSettingsBtn.addEventListener('click', (event) => { event.preventDefault(); console.log("Closing settings section!"); showSection(gameSection); });

            if (claimProfitBtn) claimProfitBtn.addEventListener('click', claimAccumulatedProfit);
            if (upgradeTapPowerBtn) upgradeTapPowerBtn.addEventListener('click', () => purchaseUpgrade('tapPower'));
            if (upgradeEnergyCapacityBtn) upgradeEnergyCapacityBtn.addEventListener('click', () => purchaseUpgrade('energyCapacity'));
            if (upgradeEnergyRegenBtn) upgradeEnergyRegenBtn.addEventListener('click', () => purchaseUpgrade('energyRegen'));
            if (copyReferralLinkBtn) copyReferralLinkBtn.addEventListener('click', () => {
                const referralLink = referralLinkDisplay.textContent;
                if (referralLink && referralLink !== 'Loading referral link...') {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = referralLink;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempInput);
                    showMessage('Referral link copied!', 'success');
                } else {
                    showMessage('Referral link not available yet.', 'info');
                }
            });
            if (redeemCoinsBtn) redeemCoinsBtn.addEventListener('click', handleRedeem);
            if (saveUsernameBtn) saveUsernameBtn.addEventListener('click', saveUsername); // New listener for saving username


            // Check if Telegram WebApp object is available and has user data
            if (typeof window.Telegram !== 'undefined' && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user) {
                console.log("Telegram WebApp detected. Attempting to get user ID.");
                // Ensure user.id exists before trying to access it
                if (window.Telegram.WebApp.initDataUnsafe.user.id) {
                    const telegramUserId = `telegram_${window.Telegram.WebApp.initDataUnsafe.user.id}`;
                    console.log(`Telegram User ID obtained: ${telegramUserId}. Calling loadGameData.`);
                    loadGameData(telegramUserId);
                } else {
                    console.error("Telegram WebApp detected, but user.id is undefined. Cannot load game data.");
                    loadingOverlay.classList.add('hidden');
                    gameWrapper.classList.add('hidden'); // Hide game wrapper explicitly
                    telegramOnlyMessage.classList.remove('hidden');
                    document.getElementById('telegram-only-message').innerHTML = `
                        <i class="fas fa-exclamation-triangle text-6xl text-red-400 mb-4"></i>
                        <h2 class="text-2xl font-bold text-red-400 mb-4">Telegram User Error</h2>
                        <p class="text-lg text-gray-300">Could not retrieve your Telegram User ID. Please ensure you are logged into Telegram.</p>
                        <p class="text-md text-gray-400 mt-2">If the issue persists, try restarting Telegram or your device.</p>
                    `;
                }
            } else {
                console.warn("Not in Telegram WebApp or user data not available. Displaying restriction message.");
                // Not in Telegram WebApp, show message and hide game
                loadingOverlay.classList.add('hidden');
                gameWrapper.classList.add('hidden'); // Hide game wrapper explicitly
                telegramOnlyMessage.classList.remove('hidden');
            }
        });

        // Cleanup on window unload (optional, but good practice for real-time listeners)
        window.addEventListener('beforeunload', () => {
            if (unsubscribeSnapshot) {
                unsubscribeSnapshot();
                console.log("Firestore listener unsubscribed on unload.");
            }
            stopGameLoops();
            console.log("Game loops stopped on unload.");
        });
    </script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</body>
</html>

